(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types'], factory) :
	(factory((global.ReactMinimalPieChart = {}),global.React,global.PropTypes));
}(this, (function (exports,React,PropTypes) { 'use strict';

var React__default = 'default' in React ? React['default'] : React;
PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;

// from http://stackoverflow.com/a/18473154

var partialCircle = function partialCircle(cx, cy, r, start, end) {
	var length = end - start;
	if (length === 0) return [];

	var fromX = r * Math.cos(start) + cx;
	var fromY = r * Math.sin(start) + cy;
	var toX = r * Math.cos(end) + cx;
	var toY = r * Math.sin(end) + cy;
	var large = Math.abs(length) <= Math.PI ? '0' : '1';
	var sweep = length < 0 ? '0' : '1';

	return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];
};

var svgPartialCircle = partialCircle;

var PI = Math.PI;

function degreesToRadians(degrees) {
  return degrees * PI / 180;
}

function evaluateViewBoxSize(ratio, baseSize) {
  // Wide ratio
  if (ratio > 1) {
    return '0 0 ' + baseSize + ' ' + baseSize / ratio;
  }
  // Narrow/squared ratio
  return '0 0 ' + baseSize * ratio + ' ' + baseSize;
}

function evaluateLabelTextAnchor() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      labelPosition = _ref.labelPosition,
      lineWidth = _ref.lineWidth,
      labelHorizontalShift = _ref.labelHorizontalShift;

  // Label in the vertical center
  if (labelHorizontalShift === 0) {
    return 'middle';
  }
  // Outward label
  if (labelPosition > 100) {
    return labelHorizontalShift > 0 ? 'start' : 'end';
  }
  // Inward label
  var innerRadius = 100 - lineWidth;
  if (labelPosition < innerRadius) {
    return labelHorizontalShift > 0 ? 'end' : 'start';
  }
  // Overlying label
  return 'middle';
}

function valueBetween(value, min, max) {
  if (value > max) return max;
  if (value < min) return min;
  return value;
}

function extractPercentage(value, percentage) {
  return value * percentage / 100;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};









var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};



var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var makePathCommands = function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {
  var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);

  return svgPartialCircle(cx, cy, // center X and Y
  radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {
    return command.join(' ');
  }).join(' ');
};

function ReactMinimalPieChartPath(_ref) {
  var cx = _ref.cx,
      cy = _ref.cy,
      startAngle = _ref.startAngle,
      lengthAngle = _ref.lengthAngle,
      radius = _ref.radius,
      lineWidth = _ref.lineWidth,
      reveal = _ref.reveal,
      title = _ref.title,
      props = objectWithoutProperties(_ref, ['cx', 'cy', 'startAngle', 'lengthAngle', 'radius', 'lineWidth', 'reveal', 'title']);

  var actualRadio = radius - lineWidth / 2;
  var pathCommands = makePathCommands(cx, cy, startAngle, lengthAngle, actualRadio);
  var strokeDasharray = void 0;
  var strokeDashoffset = void 0;

  // Animate/hide paths with "stroke-dasharray" + "stroke-dashoffset"
  // https://css-tricks.com/svg-line-animation-works/
  if (typeof reveal === 'number') {
    strokeDasharray = degreesToRadians(actualRadio) * Math.abs(lengthAngle);
    strokeDashoffset = strokeDasharray + extractPercentage(strokeDasharray, reveal);
  }

  return React__default.createElement(
    'path',
    _extends({
      d: pathCommands,
      strokeWidth: lineWidth,
      strokeDasharray: strokeDasharray,
      strokeDashoffset: strokeDashoffset
    }, props),
    title && React__default.createElement(
      'title',
      null,
      title
    )
  );
}

ReactMinimalPieChartPath.displayName = 'ReactMinimalPieChartPath';

ReactMinimalPieChartPath.propTypes = {
  cx: PropTypes.number.isRequired,
  cy: PropTypes.number.isRequired,
  startAngle: PropTypes.number,
  lengthAngle: PropTypes.number,
  radius: PropTypes.number,
  lineWidth: PropTypes.number,
  reveal: PropTypes.number,
  title: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
};

ReactMinimalPieChartPath.defaultProps = {
  startAngle: 0,
  lengthAngle: 0,
  lineWidth: 100,
  radius: 100
};

var dataPropType = PropTypes.arrayOf(PropTypes.shape({
  title: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  value: PropTypes.number.isRequired,
  key: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  color: PropTypes.string
}));

var stylePropType = PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string]));

function ReactMinimalPieChartLabel(_ref) {
  var data = _ref.data,
      dataIndex = _ref.dataIndex,
      color = _ref.color,
      props = objectWithoutProperties(_ref, ['data', 'dataIndex', 'color']);

  return React__default.createElement('text', _extends({
    textAnchor: 'middle',
    alignmentBaseline: 'middle',
    fill: color
  }, props));
}

ReactMinimalPieChartLabel.displayName = 'ReactMinimalPieChartLabel';

ReactMinimalPieChartLabel.propTypes = {
  data: dataPropType,
  dataIndex: PropTypes.number,
  color: PropTypes.string
};

var VIEWBOX_SIZE = 100;
var VIEWBOX_HALF_SIZE = VIEWBOX_SIZE / 2;

var sumValues = function sumValues(data) {
  return data.reduce(function (acc, dataEntry) {
    return acc + dataEntry.value;
  }, 0);
};

var evaluateDegreesFromValues = function evaluateDegreesFromValues(data, totalAngle, totalValue) {
  var total = totalValue || sumValues(data);
  var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);

  // Append "degrees" and "percentage" into each data entry
  return data.map(function (dataEntry) {
    var valueInPercentage = dataEntry.value / total * 100;
    return _extends({
      percentage: valueInPercentage,
      degrees: extractPercentage(normalizedTotalAngle, valueInPercentage)
    }, dataEntry);
  });
};

var makeSegmentTransitionStyle = function makeSegmentTransitionStyle(duration, easing) {
  var furtherStyles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // Merge CSS transition necessary for chart animation with the ones provided by "segmentsStyle"
  var transition = ['stroke-dashoffset ' + duration + 'ms ' + easing, furtherStyles.transition].filter(Boolean).join(',');

  return {
    transition: transition
  };
};

var makeSegments = function makeSegments(data, props, hide) {
  // Keep track of how many degrees have already been taken
  var lastSegmentAngle = props.startAngle;
  var paddingAngle = props.paddingAngle * Math.sign(props.lengthAngle);
  var reveal = void 0;
  var style = props.segmentsStyle;

  if (props.animate) {
    var transitionStyle = makeSegmentTransitionStyle(props.animationDuration, props.animationEasing, style);
    style = Object.assign({}, style, transitionStyle);
  }

  // Hide/reveal the segment?
  if (hide === true) {
    reveal = 0;
  } else if (typeof props.reveal === 'number') {
    reveal = props.reveal;
  } else if (hide === false) {
    reveal = 100;
  }

  return data.map(function (dataEntry, index) {
    var startAngle = lastSegmentAngle;
    var lengthAngle = dataEntry.degrees;
    lastSegmentAngle += lengthAngle;

    return React__default.createElement(ReactMinimalPieChartPath, {
      key: dataEntry.key || index,
      cx: props.cx,
      cy: props.cy,
      startAngle: startAngle,
      lengthAngle: lengthAngle - paddingAngle,
      radius: props.radius,
      lineWidth: extractPercentage(props.radius, props.lineWidth),
      reveal: reveal,
      title: dataEntry.title,
      style: style,
      stroke: dataEntry.color,
      strokeLinecap: props.rounded ? 'round' : undefined,
      fill: 'none',
      onMouseOver: props.onMouseOver && function (e) {
        return props.onMouseOver(e, props.data, index);
      },
      onMouseOut: props.onMouseOut && function (e) {
        return props.onMouseOut(e, props.data, index);
      },
      onClick: props.onClick && function (e) {
        return props.onClick(e, props.data, index);
      }
    });
  });
};

function renderLabelItem(option, props, value) {
  if (React__default.isValidElement(option)) {
    return React__default.cloneElement(option, props);
  }

  var label = value;
  if (typeof option === 'function') {
    label = option(props);
    if (React__default.isValidElement(label)) {
      return label;
    }
  }

  return React__default.createElement(
    ReactMinimalPieChartLabel,
    props,
    label
  );
}

var makeLabels = function makeLabels(data, props) {
  // Keep track of how many degrees have already been taken
  var lastSegmentAngle = props.startAngle;
  var paddingAngle = props.paddingAngle * Math.sign(props.lengthAngle);
  var labelPosition = extractPercentage(props.radius, props.labelPosition);

  return data.map(function (dataEntry, index) {
    var startAngle = lastSegmentAngle;
    var lengthAngle = dataEntry.degrees;
    lastSegmentAngle += lengthAngle;

    var halfAngle = startAngle + (lengthAngle - paddingAngle) / 2;
    var halfAngleRadians = degreesToRadians(halfAngle);
    var dx = Math.cos(halfAngleRadians) * labelPosition;
    var dy = Math.sin(halfAngleRadians) * labelPosition;

    // This object is passed as props to the "label" component
    var labelProps = {
      key: 'label-' + (dataEntry.key || index),
      x: props.cx,
      y: props.cy,
      dx: dx,
      dy: dy,
      textAnchor: evaluateLabelTextAnchor({
        lineWidth: props.lineWidth,
        labelPosition: props.labelPosition,
        labelHorizontalShift: dx
      }),
      data: data,
      dataIndex: index,
      color: dataEntry.color,
      style: props.labelStyle
    };

    return renderLabelItem(props.label, labelProps, dataEntry.value);
  });
};

var ReactMinimalPieChart = function (_PureComponent) {
  inherits(ReactMinimalPieChart, _PureComponent);

  function ReactMinimalPieChart(props) {
    classCallCheck(this, ReactMinimalPieChart);

    var _this = possibleConstructorReturn(this, _PureComponent.call(this, props));

    if (_this.props.animate === true) {
      _this.hideSegments = true;
    }
    return _this;
  }

  ReactMinimalPieChart.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    if (this.props.animate === true && requestAnimationFrame) {
      this.initialAnimationTimerId = setTimeout(function () {
        _this2.initialAnimationTimerId = null;
        _this2.initialAnimationRAFId = requestAnimationFrame(function () {
          _this2.initialAnimationRAFId = null, _this2.startAnimation();
        });
      });
    }
  };

  ReactMinimalPieChart.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.initialAnimationTimerId) {
      clearTimeout(this.initialAnimationTimerId);
    }
    if (this.initialAnimationRAFId) {
      cancelAnimationFrame(this.initialAnimationRAFId);
    }
  };

  ReactMinimalPieChart.prototype.startAnimation = function startAnimation() {
    this.hideSegments = false;
    this.forceUpdate();
  };

  ReactMinimalPieChart.prototype.render = function render() {
    if (this.props.data === undefined) {
      return null;
    }

    var normalizedData = evaluateDegreesFromValues(this.props.data, this.props.lengthAngle, this.props.totalValue);

    return React__default.createElement(
      'div',
      {
        className: this.props.className,
        style: this.props.style
      },
      React__default.createElement(
        'svg',
        {
          viewBox: evaluateViewBoxSize(this.props.ratio, VIEWBOX_SIZE),
          width: '100%',
          height: '100%',
          style: { display: 'block' }
        },
        makeSegments(normalizedData, this.props, this.hideSegments),
        this.props.label && makeLabels(normalizedData, this.props),
        this.props.injectSvg && this.props.injectSvg()
      ),
      this.props.children
    );
  };

  return ReactMinimalPieChart;
}(React.PureComponent);

ReactMinimalPieChart.displayName = 'ReactMinimalPieChart';

ReactMinimalPieChart.propTypes = {
  data: dataPropType,
  cx: PropTypes.number,
  cy: PropTypes.number,
  ratio: PropTypes.number,
  totalValue: PropTypes.number,
  className: PropTypes.string,
  style: stylePropType,
  segmentsStyle: stylePropType,
  startAngle: PropTypes.number,
  lengthAngle: PropTypes.number,
  paddingAngle: PropTypes.number,
  lineWidth: PropTypes.number,
  radius: PropTypes.number,
  rounded: PropTypes.bool,
  animate: PropTypes.bool,
  animationDuration: PropTypes.number,
  animationEasing: PropTypes.string,
  reveal: PropTypes.number,
  children: PropTypes.node,
  injectSvg: PropTypes.func,
  label: PropTypes.oneOfType([PropTypes.func, PropTypes.element, PropTypes.bool]),
  labelPosition: PropTypes.number,
  labelStyle: stylePropType,
  onMouseOver: PropTypes.func,
  onMouseOut: PropTypes.func,
  onClick: PropTypes.func
};

ReactMinimalPieChart.defaultProps = {
  cx: VIEWBOX_HALF_SIZE,
  cy: VIEWBOX_HALF_SIZE,
  ratio: 1,
  startAngle: 0,
  lengthAngle: 360,
  paddingAngle: 0,
  lineWidth: 100,
  radius: VIEWBOX_HALF_SIZE,
  rounded: false,
  animate: false,
  animationDuration: 500,
  animationEasing: 'ease-out',
  label: false,
  labelPosition: 50,
  onMouseOver: undefined,
  onMouseOut: undefined,
  onClick: undefined
};

exports['default'] = ReactMinimalPieChart;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
